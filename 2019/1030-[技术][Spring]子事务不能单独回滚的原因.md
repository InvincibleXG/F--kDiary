# Spring 子事务不能单独回滚的原因

最近看到一个例子，提问为啥在 `Spring` 中， **事务A方法调用相同类中的事务B方法** ，而「事务B方法出错了不能影响A方法的执行」，但是当事务B方法里出现异常时，事务B并不能回滚。即使B方法的catch块中声明`TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()；` 

也不行。

具体的现象如何，感兴趣的可以自行编写代码进行验证～



那么要去解决这个需求/问题，首先要搞清楚为啥写出的代码会和预期的结果不一致：

> 为了保证B事务方法无论怎么执行，都不会影响外层的A事务，那么只能选择在A方法中，使用try-catch块防止B事务的异常中断A事务。因此通过向上抛出异常的方法是不行的，会导致A、B同时回滚，而达不到需求。
>
> 代码作者希望借助Spring的AOP事务机制来完成回滚，不愿意手动实现回滚。
>
> 由于A事务跟B事务都在某个Service中，因此是采用的this调用方式。

所有基本的事实都已经给出，目前光看表象还看不出啥，我们应当回归问题的本质，事务的回滚是如何实现的？或者说，「是谁」负责实现的？



太基础的我就不说了，众所周知，想要让 `Spring` 帮你实现一些「AOP」的机制，那么自然是用到了「动态代理」技术，通过对目标的增强，托管方法执行的上下文，从而在方法执行前后可以随意操作。这就是简单的「AOP」了。而「AOP事务」，只不过是应用了 数据库 或者说 JDBC 提供的事务接口，让数据库负责真正的底层事务化操作。



说到这里，其实已经挺明显了，「Transaction」 依赖于 「AOP」，那么关键在于事务的切点是「方法级别」的，当进入外层A事务方法时，动态代理对象是在 **针对A事务方法进行增强** ，而不管A事务内部发生了什么。只要A方法中抛出特定异常，事务机制就生效回滚，否则不回滚。

而B方法的调用方是A方法的this对象，也就是 **并没有对B事务方法进行增强调用** ，而是直接朴素调用。



所以问题的根源就在于此，既然因为一些特殊的需求导致了A和B事务要分离，那就要「分别」进行「事务AOP」，所以不可以写出“将B事务方法直接朴素调用”的代码，而是想办法 **获取「动态代理对象」来执行B事务方法** 。



*仅仅做个简单的思路拓展，本人也没有做过多深入研究，后面要是遇到了会有补充。