#  Saturn 学习笔记

Saturn 是唯品会自主研发的分布式的定时任务的调度平台，目标是取代传统的 Linux Cron/Spring Batch Job/Quartz 的方式，做到全域统一配置、统一监控、任务高可用以及分片。

Saturn 起源于当当的 Elastic Job，增强了监控管理、作业管理、资源调度平衡、多Zookeeper集群的支持、执行节点(Executor)功能增强、支持更多脚本语言、开发增强和容器化支持等特性。

| 术语               | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| Saturn             | 定时任务调度系统                                             |
| 作业与分片         | 作业(Job)是可以独立运行的脚本(shell作业)或者具备某项功能的函数实现(java、消息作业)。作业可并发执行在多个执行节点(Executor)上，作业分片定义了作业并发执行的数量以及执行编号。比如作业分片为2，则表示作业最多可以并发执行在2个执行结点上，执行编号为0和1。作业分片调度指将作业分片指派给执行结点。比如A作业有5个分片（分片0 1 2 3 4），一共有两个执行结点 E1 和 E2 ，可以将 0 1 2 指派给 E1；3 4 指派给 E2。 |
| 域(Namespace)      | 域代表一组特定的执行结点和作业。作业必须而且只能属于某一个特定的域。一个域下通常有若干个执行结点（每个执行结点都运行在不同的独立的机器上），通过启动参数指定执行结点的-namespace将执行结点加入到某个域。执行结点必须而且只能属于某一个特定的域。域下的全部执行结点功能是对等的，域下的任何一下执行结点均有能力执行域下的全部作业，换言之，作业可以在域下任何一个执行结点执行。 |
| 组织名             | 每个namespace可以属于一个组织                                |
| 执行结点(Executor) | 执行结点(Executor)是调用并执行作业的程序。它通过定时(quartz)驱动来触发调用事件，并最终调用作业的执行入口(shell脚本或者函数实现)。执行结点只会处理指派给它的作业分片。 |
| 控制台(Console)    | 统一配置界面，可以使用控制台来查看作业状态，执行结点状态和执行日志，添加、删除作业，修改作业属性。 |



根据本人简单尝试后，对其的理解是：

**Saturn 提供了一个多进程管理的线程调度框架，基于 Zookeeper 和 DBTransaction 可以高效地进行大部分处理任务，同时具备高度的灵活性和健壮性，并且可以与常见的 Spring 项目进行集成。**

类似 我曾经使用过 Spring 的 `Schedule Job` ，将耗时的、多量的任务分配给多个异步线程去处理，但是对于更加复杂的任务需求，显然以前使用的 这种 「线程化Job」 模式是不够的(就比如从资源占用的角度)，而 Saturn 却正好能够应对更加多样化的任务处理，调度单位可扩大到进程，合理利用更多计算资源。

一个简单的Demo，比如 「去数据库里取极大量的数进行运算的任务」，可以通过对数据记录的某个特征映射到「 TaskNumber」进行任务拆分，分给每个分片分别处理具有特定「TaskNumber」标识的任务，而对任务执行的过程，可以通过访问 「Web Console」 进行监控与管理，功能非常强大。



当然我也没有能够完全使用 Saturn 的全部功能，因此建议参考官方文档，自己搭建环境进行学习调试。

[官方WIKI](https://github.com/vipshop/Saturn/wiki)



关于 Saturn 的开发，Java 任务 需要继承 BaseJavaFrame 或其子类，主要重写 prepare()、fetchData()、processData()、finish() 四个抽象方法，任务可以是 通过Cron表达式定时的，也可以由自己管理循环规则。规范上来说，应当在 `public List fetchData() `方法中与持久层交互，获取到的返回值可以直接通过框架，传输到 `public void processData(List list)` 的参数中，进行处理逻辑；整个进程生命周期从 ` public void prepare()` 方法开始，因此需要实现 ThreadLocal 对象来存储共享的自定义上下文数据，如果是定时任务，那么每次执行结束都会以 `public void finish()` 方法释放掉 ThreadLocal 对象并结束生命周期。

而其他脚本语言的任务，则是使用 Shell 脚本，让 Executor 进行解释执行。（这块还没用过）